import matplotlib.pyplot as plt
import torch
import os  # Added for path handling
from abc import ABC, abstractmethod
from vae_models import utils as vae_model_utils # Corrected import to vae_models.utils

class BaseVisualizer(ABC):
    def __init__(self, 
                 vae_model, 
                 dataset,
                 is_plot=True,  
                 save_dir=None
                 ):  # Added save_dir parameter
        """Initializes the visualizer class.

        Parameters
        ----------
        vae_model : torch.nn.Module
            The trained VAE model used for generating images and reconstructions.
        dataset : torch.utils.data.Dataset
            The dataset from which images will be sampled for visualization tasks.
        is_plot : bool, optional
            If True, plots are displayed. Defaults to True.
        is_save : bool, optional
            If True, plots are saved to `save_dir`. Defaults to False.
        save_dir : str, optional
            Directory to save plots. Required if `is_save` is True.
        """

        self.vae_model = vae_model # The vae model for generating images
        self.dataset = dataset # the dataset to be used for visualization        self.save_dir = save_dir  # Store save_dir
        self.is_plot = is_plot
        self.is_save = save_dir is not None  # Determine if saving is enabled based on save_dir

    @abstractmethod
    def _get_latent_dimension_count(self):
        """Get the number of latent dimensions from the VAE model."""
        pass

    @abstractmethod
    def _generate_single_traversal(self, 
                                   latent_factor_idx, 
                                   num_samples, 
                                   max_traversal_type, 
                                   max_traversal, ref_img
                                   ):
        """Generate traversal images for a single latent dimension."""
        pass

    @abstractmethod
    def plot_all_latent_traversals(self, 
                                   num_samples=7,
                                   use_ref_img=True, 
                                   ref_img=None,  
                                   figsize=(10, 3),
                                   **kwargs
                                   ):
        """Abstract method for plotting all latent traversals."""
        pass

################## Latent Traversal Methods ##################

    def plot_single_latent_traversal(self, 
                                     latent_factor_idx,
                                     max_traversal_type, 
                                     max_traversal,
                                     num_samples=7,
                                     use_ref_img=True, 
                                     ref_img=None, 
                                     figsize=(10, 3) 
                                     ):
        
        """Plots the images generated by traversing a single latent dimension.

        Generates images by varying the specified latent dimension while keeping others
        fixed, and then displays these images in a row.

        Parameters
        ----------
        latent_factor_idx : int
            The index of the latent dimension to traverse.
        num_samples : int, optional
            The number of steps or images to generate and plot along the traversal.
            Defaults to 10.
        use_ref_img : bool, optional
            If True, uses a reference image for traversal. If False, traversal is
            based on the prior (mean=0, std=1). Defaults to True.
        ref_img : torch.Tensor, optional
            A reference image tensor (C, H, W) to base the traversal on. Used if
            `use_ref_img` is True. If None and `use_ref_img` is True, a random
            image from the dataset is selected. Defaults to None.
        use_ref_img_lat_std : bool, optional
            If True and `use_ref_img` is True, the traversal range is scaled by the
            standard deviation of the reference image's latent encoding. Otherwise,
            a unit standard deviation is assumed. Defaults to False.
        max_traversal_type : str, optional
            Specifies how the traversal range is determined. Must be either 'probability'
            or 'absolute'. Defaults to 'probability'.
        max_traversal : float, optional
            The maximum traversal value, interpreted based on `max_traversal_type`.
            Defaults to 0.475.
        figsize : tuple, optional
            The size of the matplotlib figure. Defaults to (10, 3).
        
        Raises
        ------
        ValueError
            If `is_save` is True but `save_dir` is not provided.
        """

        if use_ref_img:
            
            if ref_img is None:
                # Randomly select an index from the dataset when ref_img is None
                random_idx = torch.randint(0, len(self.dataset), (1,)).item() # Randomly select an index from the dataset
                ref_img = self.dataset[random_idx][0] # Get the image tensor from the dataset

        else:
            ref_img = None # Use the prior (mean=0, std=1) for traversal

        # Generate the traversal images using the abstract method
        traversal_images = self._generate_single_traversal(
            latent_factor_idx=latent_factor_idx,
            num_samples=num_samples, 
            max_traversal_type=max_traversal_type, 
            max_traversal=max_traversal,  
            ref_img=ref_img,
        )
        
        # Create the plot
        fig, axes = plt.subplots(1, num_samples, figsize=figsize)

        # Handle case where num_samples is 1, axes is not an array
        if num_samples == 1:
            axes = [axes]

        for i, ax in enumerate(axes):
            img = traversal_images[i].permute(1, 2, 0).numpy() # Convert CHW to HWC for plotting
            if img.shape[2] == 1:
                ax.imshow(img, cmap='gray')
            else:
                ax.imshow(img)
            ax.axis('off')
            ax.set_xticks([])
            ax.set_yticks([])
            for spine in ax.spines.values():
                spine.set_edgecolor('white')
                spine.set_linewidth(0.2)

        fig.suptitle(f'Traversal of Latent Dimension {latent_factor_idx} ({self.vae_model.latent_factor_topologies[latent_factor_idx]})', fontsize=12, y=0.95)  # Adjust title position
        plt.tight_layout(rect=[0, 0, 1, 0.95])  # Reduce the top margin
        
        # Save plot if requested
        if self.is_save:
            if not self.save_dir:
                raise ValueError("save_dir must be provided when is_save=True")
            plt.savefig(os.path.join(self.save_dir, f'latent_traversal_dim_{latent_factor_idx}.png'))
            
        # Show plot if requested
        if self.is_plot:
            plt.show()

        # Always close the figure
        plt.close()

    def _plot_traversal_grid(self, all_traversals, num_samples, figsize):
        """Helper method to plot traversal grid (common for all models)."""
        num_latent_dims = self._get_latent_dimension_count()
        total_height = figsize[1] * num_latent_dims / 3
        fig, axes = plt.subplots(num_latent_dims, num_samples, figsize=(figsize[0], total_height))

        if num_latent_dims == 1 and num_samples == 1:
            axes = [[axes]]
        elif num_latent_dims == 1:
            axes = [axes]
        elif num_samples == 1:
            axes = axes.reshape(-1, 1)

        for latent_factor_idx in range(num_latent_dims):
            traversal_images = all_traversals[latent_factor_idx]
            for sample_idx in range(num_samples):
                ax = axes[latent_factor_idx][sample_idx]
                img = traversal_images[sample_idx].permute(1, 2, 0).numpy()
                if img.shape[2] == 1:
                    ax.imshow(img, cmap='gray')
                else:
                    ax.imshow(img)
                ax.axis('off')
                ax.set_xticks([])
                ax.set_yticks([])
                for spine in ax.spines.values():
                    spine.set_edgecolor('white')
                    spine.set_linewidth(0.5)
                if sample_idx == 0:
                    ax.text(-0.1, 0.5, f'Latent {latent_factor_idx} ({self.vae_model.latent_factor_topologies[latent_factor_idx]})', 
                            horizontalalignment='right',
                            verticalalignment='center', 
                            transform=ax.transAxes, 
                            fontsize=8)

        plt.tight_layout(pad=0.1, h_pad=0.5, w_pad=0.1)
        fig.suptitle('Latent Traversals for All Dimensions', fontsize=12, y=1.02)
        return fig

################## Reconstruction Methods ##################

    def plot_reconstructions(self, imgs, reconstructions, figsize=(10, 3)):
        """Plots original images and their reconstructions side-by-side.

        Creates a matplotlib figure displaying the original images in the top row
        and their corresponding reconstructions in the bottom row.

        Parameters
        ----------
        imgs : list of torch.Tensor
            A list of original image tensors (on CPU).
        reconstructions : list of torch.Tensor
            A list of reconstructed image tensors (on CPU).
        figsize : tuple, optional
            The size of the matplotlib figure. Defaults to (10, 3).
        
        Raises
        ------
        ValueError
            If `is_save` is True but `save_dir` is not provided.
        """
        num_images = len(imgs)
        fig, axes = plt.subplots(2, num_images, figsize=figsize)

        # Handle case where num_images is 1, axes is not a 2D array
        if num_images == 1:
            axes = axes.reshape(2, 1)

        for i in range(num_images):
            # Plot original image
            ax = axes[0, i]
            img = imgs[i].permute(1, 2, 0).numpy() # Convert CHW to HWC for plotting
            if img.shape[2] == 1:
                ax.imshow(img, cmap='gray')
            else:
                ax.imshow(img)
            ax.axis('off')
            ax.set_xticks([])
            ax.set_yticks([])
            for spine in ax.spines.values():
                spine.set_edgecolor('white')
                spine.set_linewidth(0.5)

            # Plot reconstructed image
            ax = axes[1, i]
            recon = reconstructions[i].permute(1, 2, 0).numpy() # Convert CHW to HWC
            if recon.shape[2] == 1:
                ax.imshow(recon, cmap='gray')
            else:
                ax.imshow(recon)
            ax.axis('off')
            ax.set_xticks([])
            ax.set_yticks([])
            for spine in ax.spines.values():
                spine.set_edgecolor('white')
                spine.set_linewidth(0.5)
            if i == 0:
                ax.set_title('Reconstruction', fontsize=10)

        plt.tight_layout(pad=0.1)
        
        # Save plot if requested
        if self.is_save:
            if not self.save_dir:
                raise ValueError("save_dir must be provided when is_save=True")
            plt.savefig(os.path.join(self.save_dir, 'reconstructions.png'))
            
        # Show plot if requested
        if self.is_plot:
            plt.show()

        # Always close the figure
        plt.close()
    
    def plot_random_reconstructions(self, num_samples=10, mode='mean', figsize=(10, 3)):
        """Randomly selects and plots a specified number of images and their reconstructions.

        This method combines the functionality of `random_reconstruct_sub_dataset` and
        `plot_reconstructions` to display a set of randomly chosen images alongside
        their VAE reconstructions.

        Parameters
        ----------
        num_samples : int, optional
            The number of random images to select and reconstruct. Defaults to 10.
        mode : str, optional
            Mode for reconstruction. Options are 'mean' or 'sample'. Defaults to 'mean'.
        figsize : tuple, optional
            The size of the matplotlib figure. Defaults to (10, 3).
        """
        imgs, reconstructions = vae_model_utils.random_reconstruct_sub_dataset(self.vae_model, self.dataset, num_samples, mode=mode)
        self.plot_reconstructions(imgs, reconstructions, figsize)
    
    def plot_reconstructions_sub_dataset(self, img_indices, mode='mean', figsize=(10, 3)):
        """Reconstructs and plots images from the dataset specified by their indices.

        This method combines the functionality of `reconstruct_sub_dataset` and
        `plot_reconstructions` to display a set of images alongside their VAE
        reconstructions.

        Parameters
        ----------
        img_indices : list of int or torch.Tensor
            A list or tensor containing the indices of the images to reconstruct
            from the dataset.
        mode : str, optional
            Mode for reconstruction. Options are 'mean' or 'sample'. Defaults to 'mean'.
        figsize : tuple, optional
            The size of the matplotlib figure. Defaults to (10, 3).
        """
        imgs, reconstructions = vae_model_utils.reconstruct_sub_dataset(self.vae_model, self.dataset, img_indices, mode=mode)
        self.plot_reconstructions(imgs, reconstructions, figsize)


################## Concrete Visualizer Subclasses ##################

class NVAEVisualizer(BaseVisualizer):
    """Visualizer for N-VAE models (Normal VAE with Gaussian latent space)."""
    
    def __init__(self, vae_model, dataset, is_plot=True, save_dir=None):
        super().__init__(vae_model, dataset, is_plot, save_dir)
        # Import here to avoid circular imports and make it clear which utils are used
        from vae_models.n_vae import utils as n_vae_utils
        self.n_vae_utils = n_vae_utils
    
    def _get_latent_dimension_count(self):
        """Get the number of latent dimensions from the N-VAE model."""
        return self.vae_model.latent_dim
    
    def _generate_single_traversal(self, 
                                   latent_factor_idx, 
                                   ref_img,
                                   num_samples, 
                                   max_traversal_type='probability', 
                                   max_traversal=0.95, 
                                   ):
        """Generate traversal images for a single latent dimension using N-VAE utils."""
        return self.n_vae_utils.traverse_single_latent(
            vae_model=self.vae_model,
            latent_factor_idx=latent_factor_idx,
            num_samples=num_samples,
            max_traversal_type=max_traversal_type,
            max_traversal=max_traversal,
            ref_img=ref_img
        )
    
    def plot_all_latent_traversals(self,
                                   max_traversal=0.99,
                                   max_traversal_type='probability', 
                                   num_samples=7,
                                   use_ref_img=True, 
                                   ref_img=None,  
                                   figsize=(10, 3)
                                   ):
        if use_ref_img and ref_img is None:
            random_idx = torch.randint(0, len(self.dataset), (1,)).item()
            ref_img = self.dataset[random_idx][0]

        all_traversals = self.n_vae_utils.traverse_all_latents(
            vae_model=self.vae_model,
            num_samples=num_samples,
            max_traversal_type=max_traversal_type,
            max_traversal=max_traversal,
            ref_img=ref_img
        )
        
        fig = self._plot_traversal_grid(all_traversals, num_samples, figsize)
        
        if self.is_save:
            if not self.save_dir:
                raise ValueError("save_dir must be provided when is_save=True")
            plt.savefig(os.path.join(self.save_dir, 'all_latent_traversals.png'))
            
        if self.is_plot:
            plt.show()
            
        plt.close()

class SVAEVisualizer(BaseVisualizer):
    """Visualizer for S-VAE models (Spherical VAE with toroidal latent space)."""
    
    def __init__(self, vae_model, dataset, is_plot=True, save_dir=None):
        super().__init__(vae_model, dataset, is_plot, save_dir)
        # Import here to avoid circular imports and make it clear which utils are used
        from vae_models.s_vae.toroidal_vae import utils as s_vae_utils
        self.s_vae_utils = s_vae_utils
    
    def _get_latent_dimension_count(self):
        """Get the number of latent dimensions from the S-VAE model."""
        return self.vae_model.latent_factor_num

    def _generate_single_traversal(self, 
                                   latent_factor_idx, 
                                   num_samples,
                                   ref_img, 
                                   max_traversal_type='fraction', 
                                   max_traversal=1, 
                                   ):
        """Generate traversal images for a single latent dimension using S-VAE utils.
        Also, S-VAE uses 'fraction' instead of 'probability' for max_traversal_type.
        """

        return self.s_vae_utils.traverse_single_toroidal_latent(
            vae_model=self.vae_model,
            latent_factor_idx=latent_factor_idx,
            num_samples=num_samples,
            max_traversal_type=max_traversal_type,
            max_traversal=max_traversal,
            ref_img=ref_img
        )
    
    def plot_all_latent_traversals(self,
                                   max_traversal=1,
                                   max_traversal_type='fraction', 
                                   num_samples=7,
                                   use_ref_img=True, 
                                   ref_img=None,  
                                   figsize=(10, 3)
                                   ):
        if use_ref_img and ref_img is None:
            random_idx = torch.randint(0, len(self.dataset), (1,)).item()
            ref_img = self.dataset[random_idx][0]

        all_traversals = self.s_vae_utils.traverse_all_toroidal_latents(
            vae_model=self.vae_model,
            num_samples=num_samples,
            max_traversal_type=max_traversal_type,
            max_traversal=max_traversal,
            ref_img=ref_img
        )
        
        fig = self._plot_traversal_grid(all_traversals, num_samples, figsize)
        
        if self.is_save:
            if not self.save_dir:
                raise ValueError("save_dir must be provided when is_save=True")
            plt.savefig(os.path.join(self.save_dir, 'all_latent_traversals.png'))
            
        if self.is_plot:
            plt.show()
            
        plt.close()

class SNVAEVisualizer(BaseVisualizer):
    """Visualizer for S-N-VAE models (Mixed topology VAE with both R1 and S1 latent factors)."""
    
    def __init__(self, vae_model, dataset, is_plot=True, save_dir=None):
        super().__init__(vae_model, dataset, is_plot, save_dir)
        # Import here to avoid circular imports and make it clear which utils are used
        from vae_models.s_n_vae import utils as sn_vae_utils
        self.sn_vae_utils = sn_vae_utils
        
        # Validate that the model has the required attributes
        if not hasattr(vae_model, 'latent_factor_topologies'):
            raise ValueError("VAE model must have 'latent_factor_topologies' attribute for S-N-VAE visualization")
        
        self.latent_factor_topologies = vae_model.latent_factor_topologies
    
    def _get_latent_dimension_count(self):
        """Get the number of latent factors from the S-N-VAE model."""
        return self.vae_model.latent_factor_num
    
    def _generate_single_traversal(self, 
                                   latent_factor_idx, 
                                   num_samples,
                                   max_traversal_type, 
                                   max_traversal, 
                                   ref_img):
        """Generate traversal images for a single latent dimension using S-N VAE utils."""

        return self.sn_vae_utils.traverse_single_r1_s1_latent(
            vae_model=self.vae_model,
            latent_factor_idx=latent_factor_idx,
            num_samples=num_samples,
            max_traversal_type=max_traversal_type,
            max_traversal=max_traversal,
            ref_img=ref_img
        )
        
    @property
    def latent_factor_num(self):
        """Get the number of latent factors."""
        return self._get_latent_dimension_count()

    def plot_all_latent_traversals(self,
                                   r1_max_traversal_type='probability',
                                   r1_max_traversal=0.99,
                                   s1_max_traversal_type='fraction',
                                   s1_max_traversal=1.0,
                                   num_samples=7,
                                   use_ref_img=True, 
                                   ref_img=None,  
                                   figsize=(10, 3)
                                   ):
        if use_ref_img and ref_img is None:
            random_idx = torch.randint(0, len(self.dataset), (1,)).item()
            ref_img = self.dataset[random_idx][0]

        all_traversals = self.sn_vae_utils.traverse_all_r1_s1_latents(
            vae_model=self.vae_model,
            num_samples=num_samples,
            ref_img=ref_img,
            r1_max_traversal_type=r1_max_traversal_type,
            r1_max_traversal=r1_max_traversal,
            s1_max_traversal_type=s1_max_traversal_type,
            s1_max_traversal=s1_max_traversal
        )
        
        fig = self._plot_traversal_grid(all_traversals, num_samples, figsize)
        
        if self.is_save:
            if not self.save_dir:
                raise ValueError("save_dir must be provided when is_save=True")
            plt.savefig(os.path.join(self.save_dir, 'all_latent_traversals.png'))
            
        if self.is_plot:
            plt.show()
            
        plt.close()

################## Legacy Compatibility ##################

# For backward compatibility, create an alias to the N-VAE visualizer
# This allows existing code using Visualizer to continue working
class Visualizer(NVAEVisualizer):
    """Legacy alias for NVAEVisualizer to maintain backward compatibility."""
    pass





