import matplotlib.pyplot as plt
import torch
import os  # Added for path handling
from abc import ABC, abstractmethod
from vae_models import utils as vae_model_utils # Corrected import to vae_models.utils

class BaseVisualizer(ABC):
    def __init__(self, 
                 vae_model, 
                 dataset,
                 is_plot=True,  
                 save_dir=None
                 ):  # Added save_dir parameter
        """Initializes the visualizer class.

        Parameters
        ----------
        vae_model : torch.nn.Module
            The trained VAE model used for generating images and reconstructions.
        dataset : torch.utils.data.Dataset
            The dataset from which images will be sampled for visualization tasks.
        is_plot : bool, optional
            If True, plots are displayed. Defaults to True.
        is_save : bool, optional
            If True, plots are saved to `save_dir`. Defaults to False.
        save_dir : str, optional
            Directory to save plots. Required if `is_save` is True.
        """

        self.vae_model = vae_model # The vae model for generating images
        self.dataset = dataset # the dataset to be used for visualization
        self.save_dir = save_dir  # Store save_dir
        self.is_plot = is_plot
        self.is_save = save_dir is not None  # Determine if saving is enabled based on save_dir

    @abstractmethod
    def _get_latent_dimension_count(self):
        """Get the number of latent dimensions from the VAE model."""
        pass

    @abstractmethod
    def _generate_single_traversal(self, 
                                   latent_factor_idx, 
                                   num_samples, 
                                   max_traversal_type, 
                                   max_traversal, ref_img
                                   ):
        """Generate traversal images for a single latent dimension."""
        pass

    @abstractmethod
    def plot_all_latent_traversals(self, 
                                   num_samples=7,
                                   use_ref_img=True, 
                                   ref_img=None,  
                                   figsize=(10, 3),
                                   **kwargs
                                   ):
        """Abstract method for plotting all latent traversals."""
        pass

################## Latent Traversal Methods ##################

    def plot_single_latent_traversal(self, 
                                     latent_factor_idx,
                                     max_traversal_type, 
                                     max_traversal,
                                     num_samples=7,
                                     use_ref_img=True, 
                                     ref_img=None, 
                                     figsize=(10, 3) 
                                     ):
        
        """Plots the images generated by traversing a single latent dimension.

        Generates images by varying the specified latent dimension while keeping others
        fixed, and then displays these images in a row.

        Parameters
        ----------
        latent_factor_idx : int
            The index of the latent dimension to traverse.
        num_samples : int, optional
            The number of steps or images to generate and plot along the traversal.
            Defaults to 10.
        use_ref_img : bool, optional
            If True, uses a reference image for traversal. If False, traversal is
            based on the prior (mean=0, std=1). Defaults to True.
        ref_img : torch.Tensor, optional
            A reference image tensor (C, H, W) to base the traversal on. Used if
            `use_ref_img` is True. If None and `use_ref_img` is True, a random
            image from the dataset is selected. Defaults to None.
        use_ref_img_lat_std : bool, optional
            If True and `use_ref_img` is True, the traversal range is scaled by the
            standard deviation of the reference image's latent encoding. Otherwise,
            a unit standard deviation is assumed. Defaults to False.
        max_traversal_type : str, optional
            Specifies how the traversal range is determined. Must be either 'probability'
            or 'absolute'. Defaults to 'probability'.
        max_traversal : float, optional
            The maximum traversal value, interpreted based on `max_traversal_type`.
            Defaults to 0.475.
        figsize : tuple, optional
            The size of the matplotlib figure. Defaults to (10, 3).
        
        Raises
        ------
        ValueError
            If `is_save` is True but `save_dir` is not provided.
        """

        if use_ref_img:
            
            if ref_img is None:
                # Randomly select an index from the dataset when ref_img is None
                random_idx = torch.randint(0, len(self.dataset), (1,)).item() # Randomly select an index from the dataset
                ref_img = self.dataset[random_idx][0] # Get the image tensor from the dataset

        else:
            ref_img = None # Use the prior (mean=0, std=1) for traversal

        # Generate the traversal images using the abstract method
        traversal_images = self._generate_single_traversal(
            latent_factor_idx=latent_factor_idx,
            num_samples=num_samples, 
            max_traversal_type=max_traversal_type, 
            max_traversal=max_traversal,  
            ref_img=ref_img,
        )
        
        # Create the plot
        fig, axes = plt.subplots(1, num_samples, figsize=figsize)

        # Handle case where num_samples is 1, axes is not an array
        if num_samples == 1:
            axes = [axes]

        for i, ax in enumerate(axes):
            img = traversal_images[i].permute(1, 2, 0).numpy() # Convert CHW to HWC for plotting
            if img.shape[2] == 1:
                ax.imshow(img, cmap='gray')
            else:
                ax.imshow(img)
            ax.axis('off')
            ax.set_xticks([])
            ax.set_yticks([])
            for spine in ax.spines.values():
                spine.set_edgecolor('white')
                spine.set_linewidth(0.2)

        fig.suptitle(f'Traversal of Latent Dimension {latent_factor_idx} ({self.vae_model.latent_factor_topologies[latent_factor_idx]})', fontsize=12, y=0.95)  # Adjust title position
        plt.tight_layout(rect=[0, 0, 1, 0.95])  # Reduce the top margin
        
        # Save plot if requested
        if self.is_save:
            if not self.save_dir:
                raise ValueError("save_dir must be provided when is_save=True")
            plt.savefig(os.path.join(self.save_dir, f'latent_traversal_dim_{latent_factor_idx}.png'))
            
        # Show plot if requested
        if self.is_plot:
            plt.show()

        # Always close the figure
        plt.close()

    def _plot_traversal_grid(self, all_traversals, num_samples, figsize):
        """Helper method to plot traversal grid (common for all models)."""
        num_latent_dims = self._get_latent_dimension_count()
        total_height = figsize[1] * num_latent_dims / 3
        fig, axes = plt.subplots(num_latent_dims, num_samples, figsize=(figsize[0], total_height))

        if num_latent_dims == 1 and num_samples == 1:
            axes = [[axes]]
        elif num_latent_dims == 1:
            axes = [axes]
        elif num_samples == 1:
            axes = axes.reshape(-1, 1)

        for latent_factor_idx in range(num_latent_dims):
            traversal_images = all_traversals[latent_factor_idx]
            for sample_idx in range(num_samples):
                ax = axes[latent_factor_idx][sample_idx]
                img = traversal_images[sample_idx].permute(1, 2, 0).numpy()
                if img.shape[2] == 1:
                    ax.imshow(img, cmap='gray')
                else:
                    ax.imshow(img)
                ax.axis('off')
                ax.set_xticks([])
                ax.set_yticks([])
                for spine in ax.spines.values():
                    spine.set_edgecolor('white')
                    spine.set_linewidth(0.5)
                if sample_idx == 0:
                    ax.text(-0.1, 0.5, f'Latent {latent_factor_idx} ({self.vae_model.latent_factor_topologies[latent_factor_idx]})', 
                            horizontalalignment='right',
                            verticalalignment='center', 
                            transform=ax.transAxes, 
                            fontsize=8)

        plt.tight_layout(pad=0.1, h_pad=0.5, w_pad=0.1)
        fig.suptitle('Latent Traversals for All Dimensions', fontsize=12, y=1.02)
        return fig

################## Reconstruction Methods ##################

    def plot_reconstructions(self, imgs, reconstructions, figsize=(10, 3)):
        """Plots original images and their reconstructions side-by-side.

        Creates a matplotlib figure displaying the original images in the top row
        and their corresponding reconstructions in the bottom row.

        Parameters
        ----------
        imgs : list of torch.Tensor
            A list of original image tensors (on CPU).
        reconstructions : list of torch.Tensor
            A list of reconstructed image tensors (on CPU).
        figsize : tuple, optional
            The size of the matplotlib figure. Defaults to (10, 3).
        
        Raises
        ------
        ValueError
            If `is_save` is True but `save_dir` is not provided.
        """
        num_images = len(imgs)
        fig, axes = plt.subplots(2, num_images, figsize=figsize)

        # Handle case where num_images is 1, axes is not a 2D array
        if num_images == 1:
            axes = axes.reshape(2, 1)

        for i in range(num_images):
            # Plot original image
            ax = axes[0, i]
            img = imgs[i].permute(1, 2, 0).numpy() # Convert CHW to HWC for plotting
            if img.shape[2] == 1:
                ax.imshow(img, cmap='gray')
            else:
                ax.imshow(img)
            ax.axis('off')
            ax.set_xticks([])
            ax.set_yticks([])
            for spine in ax.spines.values():
                spine.set_edgecolor('white')
                spine.set_linewidth(0.5)

            # Plot reconstructed image
            ax = axes[1, i]
            recon = reconstructions[i].permute(1, 2, 0).numpy() # Convert CHW to HWC
            if recon.shape[2] == 1:
                ax.imshow(recon, cmap='gray')
            else:
                ax.imshow(recon)
            ax.axis('off')
            ax.set_xticks([])
            ax.set_yticks([])
            for spine in ax.spines.values():
                spine.set_edgecolor('white')
                spine.set_linewidth(0.5)
            if i == 0:
                ax.set_title('Reconstruction', fontsize=10)

        plt.tight_layout(pad=0.1)
        
        # Save plot if requested
        if self.is_save:
            if not self.save_dir:
                raise ValueError("save_dir must be provided when is_save=True")
            plt.savefig(os.path.join(self.save_dir, 'reconstructions.png'))
            
        # Show plot if requested
        if self.is_plot:
            plt.show()

        # Always close the figure
        plt.close()
    
    def plot_random_reconstructions(self, num_samples=10, mode='mean', figsize=(10, 3)):
        """Randomly selects and plots a specified number of images and their reconstructions.

        This method combines the functionality of `random_reconstruct_sub_dataset` and
        `plot_reconstructions` to display a set of randomly chosen images alongside
        their VAE reconstructions.

        Parameters
        ----------
        num_samples : int, optional
            The number of random images to select and reconstruct. Defaults to 10.
        mode : str, optional
            Mode for reconstruction. Options are 'mean' or 'sample'. Defaults to 'mean'.
        figsize : tuple, optional
            The size of the matplotlib figure. Defaults to (10, 3).
        """
        imgs, reconstructions = vae_model_utils.random_reconstruct_sub_dataset(self.vae_model, self.dataset, num_samples, mode=mode)
        self.plot_reconstructions(imgs, reconstructions, figsize)
    
    def plot_reconstructions_sub_dataset(self, img_indices, mode='mean', figsize=(10, 3)):
        """Reconstructs and plots images from the dataset specified by their indices.

        This method combines the functionality of `reconstruct_sub_dataset` and
        `plot_reconstructions` to display a set of images alongside their VAE
        reconstructions.

        Parameters
        ----------
        img_indices : list of int or torch.Tensor
            A list or tensor containing the indices of the images to reconstruct
            from the dataset.
        mode : str, optional
            Mode for reconstruction. Options are 'mean' or 'sample'. Defaults to 'mean'.
        figsize : tuple, optional
            The size of the matplotlib figure. Defaults to (10, 3).
        """
        imgs, reconstructions = vae_model_utils.reconstruct_sub_dataset(self.vae_model, self.dataset, img_indices, mode=mode)
        self.plot_reconstructions(imgs, reconstructions, figsize)


################## Topology-Based Visualizer ##################

class Visualizer(BaseVisualizer):
    """
    Visualizer that handles all VAE model types based on latent_factor_topologies.
    
    Automatically detects and uses appropriate traversal methods based on the topology
    of each latent factor (R1, S1).
    """
    
    def __init__(self, vae_model, dataset, is_plot=True, save_dir=None):
        super().__init__(vae_model, dataset, is_plot, save_dir)
        
        # Import utility modules
        from vae_models.n_vae import utils as n_vae_utils
        from vae_models.s_n_vae import utils as sn_vae_utils
        
        self.n_vae_utils = n_vae_utils
        self.sn_vae_utils = sn_vae_utils
        
        # Get latent factor topologies from the model
        self.latent_factor_topologies = self._get_latent_factor_topologies()
    
    def _get_latent_factor_topologies(self):
        """Extract latent factor topologies from the VAE model."""
        # All models now have the latent_factor_topologies attribute
        return self.vae_model.latent_factor_topologies
    
    def _get_latent_dimension_count(self):
        """Get the number of latent dimensions from the VAE model."""
        return len(self.latent_factor_topologies)
    
    def _get_default_traversal_params(self, topology):
        """Get default traversal parameters based on topology type."""
        if topology == 'R1':
            return {'max_traversal_type': 'probability', 'max_traversal': 0.99}
        elif topology == 'S1':
            return {'max_traversal_type': 'fraction', 'max_traversal': 1.0}
        else:
            # Default fallback for unknown topologies
            return {'max_traversal_type': 'probability', 'max_traversal': 0.99}
    
    def _generate_single_traversal(self, 
                                   latent_factor_idx, 
                                   num_samples,
                                   max_traversal_type=None, 
                                   max_traversal=None, 
                                   ref_img=None):
        """Generate traversal images for a single latent dimension based on its topology."""
        topology = self.latent_factor_topologies[latent_factor_idx]
        
        # Use provided parameters or defaults based on topology
        if max_traversal_type is None or max_traversal is None:
            defaults = self._get_default_traversal_params(topology)
            max_traversal_type = max_traversal_type or defaults['max_traversal_type']
            max_traversal = max_traversal or defaults['max_traversal']
        
        # Route to appropriate utility function based on topology
        if topology == 'R1':
            return self.n_vae_utils.traverse_single_latent(
                vae_model=self.vae_model,
                latent_factor_idx=latent_factor_idx,
                num_samples=num_samples,
                max_traversal_type=max_traversal_type,
                max_traversal=max_traversal,
                ref_img=ref_img
            )
        elif topology == 'S1':
            return self.sn_vae_utils.traverse_single_r1_s1_latent(
                vae_model=self.vae_model,
                latent_factor_idx=latent_factor_idx,
                num_samples=num_samples,
                max_traversal_type=max_traversal_type,
                max_traversal=max_traversal,
                ref_img=ref_img
            )
        else:
            raise ValueError(f"Unsupported latent factor topology: {topology}. Only 'R1' and 'S1' are supported.")
    
    def plot_all_latent_traversals(self,
                                   num_samples=7,
                                   use_ref_img=True, 
                                   ref_img=None,
                                   reg_img_idx=None,
                                   figsize=(10, 3),
                                   # Topology-specific parameters
                                   r1_max_traversal_type='probability',
                                   r1_max_traversal=0.99,
                                   s1_max_traversal_type='fraction',
                                   s1_max_traversal=1.0,
                                   # Legacy parameters for backward compatibility
                                   max_traversal_type=None,
                                   max_traversal=None,
                                   **kwargs):
        """Plot traversals for all latent dimensions using appropriate methods per topology."""
        
        # Handle reference image selection
        if use_ref_img and ref_img is None:
            if reg_img_idx is not None:
                ref_img = self.dataset[reg_img_idx][0]
            else:
                random_idx = torch.randint(0, len(self.dataset), (1,)).item()
                ref_img = self.dataset[random_idx][0]
        
        # Always traverse each latent dimension individually based on its topology
        all_traversals = []
        for i, topology in enumerate(self.latent_factor_topologies):
            if topology == 'R1':
                params = {'max_traversal_type': r1_max_traversal_type, 'max_traversal': r1_max_traversal}
            elif topology == 'S1':
                params = {'max_traversal_type': s1_max_traversal_type, 'max_traversal': s1_max_traversal}
            else:
                # Use default parameters for unknown topologies
                params = self._get_default_traversal_params(topology)
            
            traversal = self._generate_single_traversal(
                latent_factor_idx=i,
                num_samples=num_samples,
                ref_img=ref_img,
                **params
            )
            all_traversals.append(traversal)
        
        # Plot the grid
        fig = self._plot_traversal_grid(all_traversals, num_samples, figsize)
        
        if self.is_save:
            if not self.save_dir:
                raise ValueError("save_dir must be provided when is_save=True")
            plt.savefig(os.path.join(self.save_dir, 'all_latent_traversals.png'))
            
        if self.is_plot:
            plt.show()
            
        plt.close()







